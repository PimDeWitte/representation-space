<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Representation Space Explorer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: 'Press Start 2P', cursive; color: #eee; }
        canvas { display: block; }
        #info-box, #instructions, #query-display { position: absolute; background-color: rgba(0, 0, 0, 0.7); border-radius: 8px; padding: 10px 15px; font-size: 12px; z-index: 10; }
        #info-box { top: 20px; left: 20px; border: 2px solid #0f0; color: #0f0; max-width: 300px; display: none; pointer-events: none; text-shadow: 0 0 5px #0f0; line-height: 1.6; }
        #info-box h3 { margin-top: 0; margin-bottom: 10px; font-size: 14px; text-transform: uppercase; }
        #instructions { bottom: 15px; left: 50%; transform: translateX(-50%); color: #aaa; font-size: 10px; padding: 5px 10px; text-align: center; }
        #instructions a { color: #0ff; text-decoration: none; display: block; margin-top: 5px; cursor: pointer; } /* Added cursor pointer */
        #instructions a:hover { text-decoration: underline; }
        #query-display { top: 20px; right: 20px; border: 2px solid #0ff; color: #0ff; text-shadow: 0 0 5px #0ff; }

        /* --- Overlay Styles (Animation) --- */
        #animation-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); display: none; justify-content: center; align-items: center; z-index: 100; flex-direction: column; padding: 20px; box-sizing: border-box; }
        #overlay-node-label { color: #aaa; font-size: 14px; margin-bottom: 15px; text-align: center; }
        #overlay-content { display: flex; align-items: center; justify-content: space-around; width: 80%; max-width: 800px; height: 100px; margin-bottom: 20px; position: relative; border-bottom: 1px dashed rgba(0, 255, 255, 0.3); padding-bottom: 15px; }
        .network-layer { width: 10px; height: 100%; background: linear-gradient(to bottom, rgba(0, 100, 100, 0.3), rgba(0, 200, 200, 0.6), rgba(0, 100, 100, 0.3)); border-radius: 5px; box-shadow: 0 0 8px rgba(0, 255, 255, 0.5); opacity: 0; animation: fadeInLayer 0.5s forwards; transition: box-shadow 0.15s linear, background 0.15s linear; position: relative; overflow: hidden; }
        .network-layer::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: repeating-linear-gradient( 45deg, rgba(255,255,255,0.0), rgba(255,255,255,0.0) 3px, rgba(255,255,255,0.05) 3px, rgba(255,255,255,0.05) 6px ); opacity: 0; transition: opacity 0.15s linear; }
        .network-layer:nth-child(1) { animation-delay: 0.1s; } .network-layer:nth-child(2) { animation-delay: 0.2s; } .network-layer:nth-child(3) { animation-delay: 0.3s; } .network-layer:nth-child(4) { animation-delay: 0.4s; } .network-layer:nth-child(5) { animation-delay: 0.5s; }
        .network-layer.active { box-shadow: 0 0 20px #0f0; background: linear-gradient(to bottom, rgba(0, 255, 0, 0.3), rgba(100, 255, 100, 1), rgba(0, 255, 0, 0.3)); }
        .network-layer.active::before { opacity: 0.5; }
        #signal-wave { position: absolute; left: -30px; top: 50%; height: 25px; transform: translateY(-50%); opacity: 0; transition: left 0.4s linear, opacity 0.2s linear; }
        .signal-dot-item { position: absolute; width: 6px; height: 6px; background-color: #0f0; border-radius: 50%; box-shadow: 0 0 6px #0f0; }
        #word-selection-vis { position: absolute; bottom: -10px; left: 50%; transform: translateX(-50%); width: auto; min-width: 150px; padding: 5px; background-color: rgba(0, 0, 0, 0.6); border: 1px solid #555; border-radius: 4px; text-align: center; opacity: 0; transition: opacity 0.15s ease-out; pointer-events: none; display: flex; justify-content: center; align-items: center; gap: 8px; }
        #word-selection-vis.visible { opacity: 1; }
        .prob-word { font-size: 10px; padding: 2px 4px; border-radius: 3px; }
        .prob-word.selected { color: #0f0; border: 1px solid #0f0; background-color: rgba(0, 255, 0, 0.2); font-weight: bold; }
        .prob-word.alternative { color: #777; border: 1px solid #444; background-color: rgba(80, 80, 80, 0.2); opacity: 0.7; }
        #overlay-output-container { width: 80%; max-width: 800px; min-height: 80px; text-align: left; border: 1px dashed #0ff; padding: 15px; border-radius: 5px; background-color: rgba(0, 50, 50, 0.3); margin-top: 10px; }
        #overlay-output { font-size: 16px; color: #0f0; text-shadow: 0 0 8px #0f0; line-height: 1.6; }
        #overlay-output .current-word { background-color: rgba(0, 255, 0, 0.3); padding: 0 2px; border-radius: 2px; animation: fadeHighlight 0.8s forwards; }
        #overlay-explanation { color: #888; font-size: 10px; margin-top: 20px; max-width: 600px; text-align: center; line-height: 1.5; }
        #overlay-explanation a { color: #aaa; text-decoration: underline; }
        #overlay-explanation a:hover { color: #ccc; }
        .close-overlay-btn { position: absolute; top: 20px; right: 20px; background-color: #ff0000; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-family: 'Press Start 2P', cursive; font-size: 14px; box-shadow: 0 0 10px #ff0000; transition: background-color 0.2s; }
        .close-overlay-btn:hover { background-color: #cc0000; }

        /* --- Disclaimer Overlay Styles --- */
        #disclaimer-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(10, 10, 20, 0.95); /* Slightly different background */
            display: none; /* Hidden by default */
            justify-content: center; align-items: center;
            z-index: 100; padding: 30px; box-sizing: border-box;
            overflow-y: auto; /* Allow scrolling if content overflows */
        }
        #disclaimer-content {
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid #0ff;
            border-radius: 8px;
            padding: 20px 30px;
            max-width: 800px;
            width: 90%;
            color: #ccc; /* Lighter text color */
            font-size: 13px; /* Slightly larger base font */
            line-height: 1.7;
            font-family: sans-serif; /* Use a more readable font */
        }
         #disclaimer-content h2 {
             font-family: 'Press Start 2P', cursive; /* Keep title font */
             color: #0ff;
             font-size: 18px;
             margin-bottom: 20px;
             text-align: center;
             text-shadow: 0 0 5px #0ff;
         }
         #disclaimer-content h3 { /* Style subheadings */
             font-family: 'Press Start 2P', cursive;
             color: #eee;
             font-size: 14px;
             margin-top: 25px;
             margin-bottom: 10px;
             border-bottom: 1px dashed #555;
             padding-bottom: 5px;
         }
         #disclaimer-content p, #disclaimer-content li {
             margin-bottom: 10px;
         }
         #disclaimer-content strong {
             color: #fff;
             font-weight: normal; /* Reset bold, rely on color */
         }
         #disclaimer-content ul {
             list-style: disc;
             margin-left: 20px;
         }

        @keyframes fadeInLayer { from { opacity: 0; transform: scaleY(0.5); } to { opacity: 1; transform: scaleY(1); } }
        @keyframes nodeClickFlash { 0%, 100% { transform: scale(1.0); } 50% { transform: scale(1.5); } }
        @keyframes fadeHighlight { from { background-color: rgba(0, 255, 0, 0.3); } to { background-color: transparent; } }
    </style>
</head>
<body>
    <div id="main-visualization">
        <div id="info-box"><h3 id="info-label">...</h3><p id="info-description">...</p></div>
        <div id="instructions">
            Click & Drag: Rotate | Scroll: Zoom | Hover: Inspect
            <a id="show-disclaimer-link" href="#">Disclaimer / Accuracy Info</a>
            <a href="https://github.com/PimDeWitte/representation-space" target="_blank" rel="noopener noreferrer">GitHub Repo</a>
        </div>
        <div id="query-display">Query: <span id="current-query">...</span></div>
        <canvas id="representation-canvas"></canvas>
    </div>

    <div id="animation-overlay">
         <div id="overlay-node-label">LLM Generation for Concept: ...</div>
         <div id="overlay-content">
            <div class="network-layer"></div> <div class="network-layer"></div> <div class="network-layer"></div> <div class="network-layer"></div> <div class="network-layer"></div>
            <div id="signal-wave"></div>
             <div id="word-selection-vis"></div>
        </div>
        <div id="overlay-output-container">
            <p id="overlay-output"></p> </div>
         <div id="overlay-explanation">
             This is a simplified view of how LLMs generate words, for a great tutorial on how this actually works, see <a href="https://www.youtube.com/watch?v=7xTGNNLPyMI&pp=ygUPa2FycGF0aHkgYW5kcmVq" target="_blank" rel="noopener noreferrer">https://www.youtube.com/watch?v=7xTGNNLPyMI&pp=ygUPa2FycGF0aHkgYW5kcmVq</a>
         </div>
        <button id="close-animation-overlay-btn" class="close-overlay-btn">X</button> </div>

    <div id="disclaimer-overlay">
         <div id="disclaimer-content">
             <h2>Understanding This Visualization: Accuracy and Simplification</h2>
             <p>Welcome! This interactive visualization aims to provide intuition about complex concepts like representation spaces, neural network layers, and Large Language Model (LLM) text generation. While it uses visual metaphors grounded in real principles, it's important to understand that it is a <strong>simplified analogy</strong>, not a scientifically rigorous simulation.</p>

             <h3>What This Demo Conceptually Represents:</h3>
             <ul>
                 <li><strong>Representation Spaces:</strong> The core idea of mapping concepts (like words or topics) to points in a multi-dimensional space, where similar concepts tend to be closer together, is accurately portrayed. This is fundamental to how many AI models understand relationships in data.</li>
                 <li><strong>Layered Processing:</strong> Neural networks, including LLMs, process information through sequential layers or stages of computation. The overlay animation showing distinct layers captures this basic architectural principle.</li>
                 <li><strong>Autoregressive Generation:</strong> The overlay's word-by-word text generation correctly reflects the sequential, token-by-token nature of how most LLMs produce output.</li>
                 <li><strong>Probabilistic Selection:</strong> The brief visualization showing alternative words alongside the selected word hints at the probabilistic nature of LLM output, where the model chooses the next word from many possibilities based on learned probabilities.</li>
             </ul>

             <h3>Important Simplifications and Metaphors:</h3>
             <ul>
                 <li><strong>Concept Positions & Connections:</strong> The specific locations of concepts and the structure of the clusters in the 3D view are illustrative examples, not derived from real model training data. The lines connecting cluster centers represent conceptual links abstractly; their varying opacity is a random visual effect symbolizing connection strength or 'weights', not depicting actual learned parameters.</li>
                 <li><strong>Querying:</strong> The query simulation uses basic keyword matching. Real systems use complex vector mathematics (like cosine similarity) to find the closest concepts in the high-dimensional space.</li>
                 <li><strong>Neural Network Layers:</strong> The visual representation of layers is highly abstract. It doesn't show the intricate mathematical operations (matrix multiplications, activation functions) or complex architectures (like the attention mechanisms crucial to modern LLMs like Transformers) occurring within them. The subtle pattern change in active layers is merely a visual cue for processing.</li>
                 <li><strong>Signal Flow:</strong> The "signal wave" moving linearly is a simplification. Real processing involves massive parallelism within layers and more complex information flow.</li>
                 <li><strong>Word Probabilities & Output:</strong> The visualization shows only a few generic alternatives during word selection. Real LLMs calculate probabilities over tens of thousands of possible words/tokens at each step and use sophisticated sampling strategies to choose the next one. The generated sentences themselves are predefined examples for this demo, not dynamically created based on learned language patterns.</li>
             </ul>

             <h3>Conclusion:</h3>
             <p>Please enjoy this visualization as an interactive tool to build intuition about how AI models can represent and process information. It uses analogies to make these ideas more accessible. For a deeper, technically accurate understanding of these concepts, we encourage further reading and study of machine learning and neural network principles.</p>
         </div>
         <button id="close-disclaimer-overlay-btn" class="close-overlay-btn">X</button> </div>


    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Configuration ---
        const nodeSize = 0.5; const highlightColor = 0x00ff00; const defaultColor = 0xffffff;
        const clickHighlightColor = 0xffffff; const queryInterval = 3000; const numNetworkLayers = 5;
        const clickEffectDuration = 500; const transitionDelay = 500; const newNodeSpread = 6;
        const numSignalDots = 5;
        const layerPassDuration = 1200; const wordSelectionDuration = 450; const wordAppendDelay = 100;
        const clusterLineColor = 0x555555;
        const clusterLineGlowColor = 0xffffff; // White glow

        // --- Helper Functions ---
        function randomPosition(baseX, baseY, baseZ, spread) { return new THREE.Vector3( baseX + (Math.random() * spread - spread / 2), baseY + (Math.random() * spread - spread / 2), baseZ + (Math.random() * spread - spread / 2) ); }
        const genericAlternatives = ["the", "a", "is"];
        const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

        // --- Node Data Generation ---
        const generatedNodes = [];
        const categories = { /* ... (same categories definition) ... */
            "Element": { labels: ["Hydrogen", "Helium", "Lithium", "Beryllium", "Boron", "Carbon", "Nitrogen", "Oxygen", "Fluorine", "Neon", "Sodium", "Magnesium", "Aluminium", "Silicon", "Phosphorus", "Sulfur", "Chlorine", "Argon", "Potassium", "Calcium"], base: [15, 15, 5] },
            "City": { labels: ["Tokyo", "Delhi", "Shanghai", "Sao Paulo", "Mumbai", "Mexico City", "Beijing", "Osaka", "Cairo", "New York", "Dhaka", "Karachi", "Buenos Aires", "Kolkata", "Istanbul", "Lagos", "Manila", "Rio de Janeiro", "Guangzhou", "Los Angeles"], base: [-15, 15, 5] },
            "Country": { labels: ["China", "India", "USA", "Indonesia", "Pakistan", "Brazil", "Nigeria", "Bangladesh", "Russia", "Mexico", "Japan", "Ethiopia", "Philippines", "Egypt", "Vietnam", "DR Congo", "Turkey", "Iran", "Germany", "Thailand"], base: [15, -15, 5] },
            "Shape": { labels: ["Circle", "Square", "Triangle", "Rectangle", "Pentagon", "Hexagon", "Octagon", "Sphere", "Cube", "Pyramid", "Cylinder", "Cone", "Torus", "Ellipse", "Rhombus", "Trapezoid", "Star", "Heart", "Cross", "Arrow"], base: [-15, -15, 5] },
            "Instrument": { labels: ["Piano", "Guitar", "Violin", "Drums", "Trumpet", "Flute", "Saxophone", "Cello", "Clarinet", "Harp", "Trombone", "Accordion", "Ukulele", "Banjo", "Mandolin", "Xylophone", "Harmonica", "Bagpipes", "Didgeridoo", "Sitar"], base: [5, 15, 15] },
            "Emotion": { labels: ["Joy", "Sadness", "Anger", "Fear", "Surprise", "Disgust", "Trust", "Anticipation", "Love", "Guilt", "Shame", "Envy", "Jealousy", "Hope", "Gratitude", "Pride", "Contempt", "Interest", "Awe", "Confusion"], base: [5, -15, 15] },
            "Science Concept": { labels: ["Gravity", "Evolution", "Relativity", "Quantum", "DNA", "Photosynthesis", "Entropy", "Thermodynamics", "Big Bang", "Black Hole", "Plate Tectonics", "Magnetism", "Electricity", "Atom", "Molecule", "Cell", "Virus", "Bacteria", "Ecosystem", "Climate"], base: [15, 5, 15] },
            "Math Concept": { labels: ["Algebra", "Calculus", "Geometry", "Trigonometry", "Statistics", "Probability", "Logic", "Set Theory", "Number Theory", "Topology", "Fractal", "Vector", "Matrix", "Integral", "Derivative", "Theorem", "Axiom", "Function", "Variable", "Constant"], base: [-15, 5, 15] },
            "Verb": { labels: ["Run", "Walk", "Think", "Create", "Analyze", "Synthesize", "Communicate", "Observe", "Learn", "Teach", "Build", "Destroy", "Explore", "Discover", "Imagine", "Calculate", "Measure", "Predict", "Test", "Validate"], base: [5, 15, -15] },
            "Adjective": { labels: ["Fast", "Slow", "Bright", "Dark", "Complex", "Simple", "Abstract", "Concrete", "Large", "Small", "Hot", "Cold", "Heavy", "Light", "Hard", "Soft", "Rough", "Smooth", "Sharp", "Dull"], base: [5, -15, -15] }
        };
        const clusterCenters = {};
        for (const categoryName in categories) { /* ... (same generation logic, includes clusterCenter) ... */
             const category = categories[categoryName]; const [bx, by, bz] = category.base; const centerPoint = new THREE.Vector3(bx, by, bz); clusterCenters[categoryName] = centerPoint;
             category.labels.forEach(label => { generatedNodes.push({ position: randomPosition(bx, by, bz, newNodeSpread), label: label, category: categoryName, clusterCenter: centerPoint, info: `...`, color: Math.random() * 0xffffff, sentence: `Concept '${label}' represents the ${categoryName.toLowerCase()} ${label}.` }); });
        }
        generatedNodes.forEach(n => { if (!n.info) n.info = `Info about ${n.label}.`; });

        // --- Original Sample Data ---
        const originalNodesData = [ /* ... (same original data with category and clusterCenter added) ... */
             { position: new THREE.Vector3(5, 0, 0), label: "Apple", category: "Fruit", clusterCenter: new THREE.Vector3(5, 0, 0), info: "...", color: 0xff0000, sentence: "..." }, { position: new THREE.Vector3(5.5, 0.5, 0.2), label: "Banana", category: "Fruit", clusterCenter: new THREE.Vector3(5, 0, 0), info: "...", color: 0xffff00, sentence: "..." }, { position: new THREE.Vector3(4.8, -0.3, -0.5), label: "Orange", category: "Fruit", clusterCenter: new THREE.Vector3(5, 0, 0), info: "...", color: 0xffa500, sentence: "..." }, { position: new THREE.Vector3(5.2, 0.8, -0.8), label: "Grape", category: "Fruit", clusterCenter: new THREE.Vector3(5, 0, 0), info: "...", color: 0x800080, sentence: "..." }, { position: new THREE.Vector3(-5, 0, 0), label: "Red", category: "Color", clusterCenter: new THREE.Vector3(-5, 0, 0), info: "...", color: 0xff0000, sentence: "..." }, { position: new THREE.Vector3(-5.2, 0.6, -0.3), label: "Green", category: "Color", clusterCenter: new THREE.Vector3(-5, 0, 0), info: "...", color: 0x00ff00, sentence: "..." }, { position: new THREE.Vector3(-4.5, -0.5, 0.4), label: "Blue", category: "Color", clusterCenter: new THREE.Vector3(-5, 0, 0), info: "...", color: 0x0000ff, sentence: "..." }, { position: new THREE.Vector3(-5.5, -0.2, -0.6), label: "Yellow", category: "Color", clusterCenter: new THREE.Vector3(-5, 0, 0), info: "...", color: 0xffff00, sentence: "..." }, { position: new THREE.Vector3(0, 0, 5), label: "Abstract", category: "Concept", clusterCenter: new THREE.Vector3(0, 0, 5), info: "...", color: 0xaaaaaa, sentence: "..." }, { position: new THREE.Vector3(0.5, 0.5, 5.5), label: "Concrete", category: "Concept", clusterCenter: new THREE.Vector3(0, 0, 5), info: "...", color: 0x555555, sentence: "..." }, { position: new THREE.Vector3(-0.3, -0.4, 4.8), label: "Idea", category: "Concept", clusterCenter: new THREE.Vector3(0, 0, 5), info: "...", color: 0xcccccc, sentence: "..." }, { position: new THREE.Vector3(0, 5, 0), label: "Dog", category: "Animal", clusterCenter: new THREE.Vector3(0, 5, 0), info: "...", color: 0x8B4513, sentence: "..." }, { position: new THREE.Vector3(0.5, 5.5, 0.3), label: "Cat", category: "Animal", clusterCenter: new THREE.Vector3(0, 5, 0), info: "...", color: 0x808080, sentence: "..." }, { position: new THREE.Vector3(-0.4, 4.8, -0.2), label: "Bird", category: "Animal", clusterCenter: new THREE.Vector3(0, 5, 0), info: "...", color: 0xADD8E6, sentence: "..." }, { position: new THREE.Vector3(0.2, 5.2, -0.5), label: "Fish", category: "Animal", clusterCenter: new THREE.Vector3(0, 5, 0), info: "...", color: 0x00008B, sentence: "..." }, { position: new THREE.Vector3(0, -5, 0), label: "Car", category: "Vehicle", clusterCenter: new THREE.Vector3(0, -5, 0), info: "...", color: 0x708090, sentence: "..." }, { position: new THREE.Vector3(0.6, -5.4, 0.1), label: "Bicycle", category: "Vehicle", clusterCenter: new THREE.Vector3(0, -5, 0), info: "...", color: 0xB0C4DE, sentence: "..." }, { position: new THREE.Vector3(-0.5, -4.7, -0.3), label: "Airplane", category: "Vehicle", clusterCenter: new THREE.Vector3(0, -5, 0), info: "...", color: 0xD3D3D3, sentence: "..." }, { position: new THREE.Vector3(0.3, -5.8, -0.6), label: "Boat", category: "Vehicle", clusterCenter: new THREE.Vector3(0, -5, 0), info: "...", color: 0x4682B4, sentence: "..." },
        ];
        originalNodesData.forEach(n => { /* ... (same default info/sentence/center assignment) ... */
            if (!n.info) n.info = `Info about ${n.label}.`; if (!n.sentence) n.sentence = `Sentence about ${n.label}.`; if (!n.clusterCenter) { if (n.category === "Fruit") n.clusterCenter = new THREE.Vector3(5, 0, 0); else if (n.category === "Color") n.clusterCenter = new THREE.Vector3(-5, 0, 0); else if (n.category === "Concept") n.clusterCenter = new THREE.Vector3(0, 0, 5); else if (n.category === "Animal") n.clusterCenter = new THREE.Vector3(0, 5, 0); else if (n.category === "Vehicle") n.clusterCenter = new THREE.Vector3(0, -5, 0); else n.clusterCenter = new THREE.Vector3(0,0,0); } if (!clusterCenters[n.category]) { clusterCenters[n.category] = n.clusterCenter; }
         });

        const nodesData = [...originalNodesData, ...generatedNodes];
        const sampleQueries = ["Yellow Fruit", "Flying Vehicle", "Pet", "Primary Color", "Grows in Water", "Citrus", "Idea", "Engine Powered", "Element", "City", "Country", "Shape", "Instrument", "Emotion", "Science Concept", "Math Concept", "Verb", "Adjective"];
        let currentQueryIndex = 0;

        // --- Three.js Setup Variables & DOM Refs ---
        let scene, camera, renderer, controls; let raycaster, mouse; let nodes = [];
        let intersectedObject = null; let currentlyQueriedNode = null; let queryIntervalId = null;
        let animationFrameId = null; let nodeBeingClicked = null; let clickEffectStartTime = 0;
        let clusterConnectionLines = [];
        let defaultLineMaterial, glowLineMaterial;

        const infoBox = document.getElementById('info-box'); /* ... other DOM refs ... */
        const infoLabel = document.getElementById('info-label'); const infoDescription = document.getElementById('info-description');
        const canvas = document.getElementById('representation-canvas'); const currentQuerySpan = document.getElementById('current-query'); const mainVisualizationDiv = document.getElementById('main-visualization');
        const animationOverlay = document.getElementById('animation-overlay'); const overlayNodeLabel = document.getElementById('overlay-node-label'); const overlayContent = document.getElementById('overlay-content');
        const signalWaveContainer = document.getElementById('signal-wave');
        const wordSelectionVis = document.getElementById('word-selection-vis');
        const overlayOutputContainer = document.getElementById('overlay-output-container');
        const overlayOutput = document.getElementById('overlay-output');
        const closeAnimationOverlayBtn = document.getElementById('close-animation-overlay-btn'); // Specific ID
        const networkLayerDivs = overlayContent.querySelectorAll('.network-layer');
        const disclaimerOverlay = document.getElementById('disclaimer-overlay'); // Ref for disclaimer overlay
        const showDisclaimerLink = document.getElementById('show-disclaimer-link'); // Ref for footer link
        const closeDisclaimerOverlayBtn = document.getElementById('close-disclaimer-overlay-btn'); // Ref for disclaimer close btn

        // --- Initialization ---
        function init() {
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x111111); scene.fog = new THREE.Fog(0x111111, 20, 70);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.z = 25;
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(window.devicePixelRatio);
            const ambientLight = new THREE.AmbientLight(0xaaaaaa); scene.add(ambientLight); const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5); directionalLight.position.set(5, 10, 7.5); scene.add(directionalLight);
            controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.05; controls.screenSpacePanning = false; controls.minDistance = 2; controls.maxDistance = 60;
            raycaster = new THREE.Raycaster(); mouse = new THREE.Vector2();

            // Create Concept Nodes
            const geometry = new THREE.SphereGeometry(nodeSize, 16, 8);
            nodesData.forEach(data => { /* ... (same node creation, includes clusterCenter) ... */
                 const material = new THREE.MeshLambertMaterial({ color: data.color || defaultColor }); const nodeMesh = new THREE.Mesh(geometry, material); nodeMesh.position.copy(data.position);
                 nodeMesh.userData = { label: data.label, info: data.info, sentence: data.sentence, category: data.category, clusterCenter: data.clusterCenter, originalColor: new THREE.Color(data.color || defaultColor), isNode: true };
                 scene.add(nodeMesh); nodes.push(nodeMesh);
             });

             // Create Cluster Connection Lines Materials
             defaultLineMaterial = new THREE.LineBasicMaterial({ color: clusterLineColor, transparent: true, opacity: 0.3 });
             glowLineMaterial = new THREE.LineBasicMaterial({ color: clusterLineGlowColor, transparent: true, opacity: 1.0 }); // Base glow material, opacity set on clone

             // Create Individual Cluster Connection Lines
             const centerPoints = Object.values(clusterCenters);
             for (let i = 0; i < centerPoints.length; i++) {
                 for (let j = i + 1; j < centerPoints.length; j++) {
                     const points = [centerPoints[i], centerPoints[j]];
                     const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                     const line = new THREE.Line(lineGeometry, defaultLineMaterial);
                     scene.add(line);
                     clusterConnectionLines.push({ line: line, centerA: centerPoints[i], centerB: centerPoints[j] });
                 }
             }

            // Create signal dot elements
            signalWaveContainer.innerHTML = '';
            for (let i = 0; i < numSignalDots; i++) { /* ... (same dot creation) ... */
                const dot = document.createElement('div'); dot.classList.add('signal-dot-item');
                dot.style.top = `${(i / (numSignalDots - 1)) * 100 - 50}%`; dot.style.transform = `translateY(-50%)`;
                signalWaveContainer.appendChild(dot);
            }

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('mousemove', onMouseMove, false);
            canvas.addEventListener('click', onCanvasClick, false);
            closeAnimationOverlayBtn.addEventListener('click', hideAnimationOverlay, false); // Use specific ID
            showDisclaimerLink.addEventListener('click', showDisclaimerOverlay, false); // Listener for disclaimer link
            closeDisclaimerOverlayBtn.addEventListener('click', hideDisclaimerOverlay, false); // Listener for disclaimer close

            startQueryCycle();
            startAnimationLoop();
         }

        // --- Animation Loop Control ---
        function startAnimationLoop() { if (!animationFrameId) { animate(); } }
        function stopAnimationLoop() { if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } }

        // --- Event Handlers ---
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        function onMouseMove(event) { mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1; }
        function onCanvasClick(event) { /* ... (same click logic) ... */
            if (animationOverlay.style.display === 'flex' || nodeBeingClicked || disclaimerOverlay.style.display === 'flex') return; // Prevent click if any overlay is open
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera); const intersects = raycaster.intersectObjects(nodes);
            if (intersects.length > 0 && intersects[0].object.userData.isNode) {
                const clickedNode = intersects[0].object;
                if (clickedNode.userData.sentence) {
                    nodeBeingClicked = clickedNode; clickEffectStartTime = Date.now();
                    setTimeout(() => { if (nodeBeingClicked === clickedNode) { showAnimationOverlay(clickedNode.userData.label, clickedNode.userData.sentence); nodeBeingClicked = null; } }, transitionDelay);
                }
            }
        }

        // --- Overlay Controls ---
        let animationControl = { timeoutId: null, wordIndex: 0, words: [], isCancelled: false };
        function showAnimationOverlay(label, sentence) {
            if (disclaimerOverlay.style.display === 'flex') return; // Don't open if disclaimer is open
            stopAnimationLoop(); mainVisualizationDiv.style.display = 'none';
            overlayNodeLabel.textContent = `LLM Generation for Concept: ${label}`;
            animationOverlay.style.display = 'flex';
            // Reset state
            clearTimeout(animationControl.timeoutId); animationControl.isCancelled = false;
            signalWaveContainer.style.transition = 'none'; signalWaveContainer.style.opacity = '0'; signalWaveContainer.style.left = '-30px';
            overlayOutput.innerHTML = ''; wordSelectionVis.innerHTML = ''; wordSelectionVis.classList.remove('visible');
            networkLayerDivs.forEach(layer => layer.classList.remove('active'));
            void signalWaveContainer.offsetWidth;
            animationControl.words = sentence.split(' '); animationControl.wordIndex = 0;
            animateLLMStep();
        }
        function hideAnimationOverlay() {
             animationControl.isCancelled = true; clearTimeout(animationControl.timeoutId);
             animationOverlay.style.display = 'none'; mainVisualizationDiv.style.display = 'block';
             nodeBeingClicked = null; startAnimationLoop();
        }
        function showDisclaimerOverlay(event) {
            event.preventDefault(); // Prevent default link behavior
            if (animationOverlay.style.display === 'flex') return; // Don't open if animation overlay is open
            stopAnimationLoop();
            mainVisualizationDiv.style.display = 'none';
            disclaimerOverlay.style.display = 'flex';
        }
        function hideDisclaimerOverlay() {
            disclaimerOverlay.style.display = 'none';
            mainVisualizationDiv.style.display = 'block';
            startAnimationLoop();
        }

        // Updated LLM Animation Step (async/await)
        async function animateLLMStep() {
            if (animationControl.isCancelled) return;

            if (animationControl.wordIndex >= animationControl.words.length) {
                wordSelectionVis.innerHTML = `<span class="prob-word selected">Complete!</span>`;
                wordSelectionVis.classList.add('visible');
                // Use timeoutId from control object
                animationControl.timeoutId = setTimeout(() => { if (!animationControl.isCancelled) wordSelectionVis.classList.remove('visible'); }, 1500);
                return;
            }

            const currentWord = animationControl.words[animationControl.wordIndex];
            const stepDuration = layerPassDuration / (numNetworkLayers + 1);

            // --- Pass through layers ---
            signalWaveContainer.style.transition = 'none'; signalWaveContainer.style.left = '-30px';
            void signalWaveContainer.offsetWidth; signalWaveContainer.style.opacity = '1';
            signalWaveContainer.style.transition = `left ${stepDuration}ms linear, opacity 0.2s linear`;

            for (let currentLayer = 1; currentLayer <= numNetworkLayers + 1; currentLayer++) {
                if (animationControl.isCancelled) return;
                const targetX = ( (currentLayer -1) * (overlayContent.offsetWidth / numNetworkLayers)) ;
                signalWaveContainer.style.left = `${targetX}px`;
                if (currentLayer > 1 && currentLayer <= numNetworkLayers + 1) networkLayerDivs[currentLayer - 2].classList.remove('active');
                if (currentLayer > 0 && currentLayer <= numNetworkLayers) networkLayerDivs[currentLayer - 1].classList.add('active');
                await delay(stepDuration);
            }
             if (!animationControl.isCancelled && numNetworkLayers > 0) networkLayerDivs[numNetworkLayers - 1].classList.remove('active');
             signalWaveContainer.style.opacity = '0';

            // --- Word Selection Visualization ---
            if (animationControl.isCancelled) return;
            wordSelectionVis.innerHTML = '';
            genericAlternatives.forEach(altWord => { if (altWord !== currentWord) { const altSpan = document.createElement('span'); altSpan.textContent = altWord; altSpan.classList.add('prob-word', 'alternative'); wordSelectionVis.appendChild(altSpan); } });
            const selectedSpan = document.createElement('span'); selectedSpan.textContent = currentWord; selectedSpan.classList.add('prob-word', 'selected'); const insertIndex = Math.floor(Math.random() * (wordSelectionVis.children.length + 1)); wordSelectionVis.insertBefore(selectedSpan, wordSelectionVis.children[insertIndex]);
            wordSelectionVis.classList.add('visible');
            await delay(wordSelectionDuration);

            // --- Append Word ---
            if (animationControl.isCancelled) return;
            wordSelectionVis.classList.remove('visible');
            const span = document.createElement('span'); span.textContent = currentWord + ' '; span.classList.add('current-word');
            overlayOutput.appendChild(span);
            animationControl.wordIndex++;

            // --- Schedule Next Step ---
            if (!animationControl.isCancelled) {
                 animationControl.timeoutId = setTimeout(animateLLMStep, wordAppendDelay);
            }
        }


        // --- Core Logic (Query Cycle, Intersection Checks) ---
        function startQueryCycle() { /* ... (same) ... */ if (queryIntervalId) clearInterval(queryIntervalId); const runQuery = () => { const query = sampleQueries[currentQueryIndex]; currentQuerySpan.textContent = query; processQuery(query); currentQueryIndex = (currentQueryIndex + 1) % sampleQueries.length; }; runQuery(); queryIntervalId = setInterval(runQuery, queryInterval); }

        // Updated processQuery for random line glow opacity (reduced range: 0.25 - 0.5)
        function processQuery(query) {
            currentlyQueriedNode = null;
            clusterConnectionLines.forEach(lineData => { if (lineData.line.material !== defaultLineMaterial) { lineData.line.material = defaultLineMaterial; } });
            const queryLower = query.toLowerCase(); const queryWords = queryLower.split(' '); let bestMatch = null;
            for (const node of nodes) { /* ... (find bestMatch same as before) ... */
                const labelLower = node.userData.label.toLowerCase(); const infoLower = node.userData.info.toLowerCase(); let matchScore = 0; for(const word of queryWords) { if (labelLower.includes(word) || infoLower.includes(word) || (node.userData.category && node.userData.category.toLowerCase().includes(word))) { matchScore++; } } if (matchScore > 0) { if (!bestMatch) { bestMatch = node; } }
            }
            currentlyQueriedNode = bestMatch;

            if (currentlyQueriedNode && currentlyQueriedNode.userData.clusterCenter) {
                const targetCenter = currentlyQueriedNode.userData.clusterCenter;
                clusterConnectionLines.forEach(lineData => {
                    if (lineData.centerA.equals(targetCenter) || lineData.centerB.equals(targetCenter)) {
                        lineData.line.material = glowLineMaterial.clone();
                        // Set random opacity simulating weight (Reduced Range: 0.25 to 0.5)
                        lineData.line.material.opacity = (Math.random() * 0.5 + 0.5) * 0.5;
                    }
                });
            }
         }

        function checkIntersections() { /* ... (same) ... */ raycaster.setFromCamera(mouse, camera); const intersects = raycaster.intersectObjects(nodes); if (intersectedObject && intersectedObject !== currentlyQueriedNode && intersectedObject !== nodeBeingClicked) { intersectedObject.material.color.copy(intersectedObject.userData.originalColor); } if (intersects.length > 0 && intersects[0].object.userData.isNode) { const currentHover = intersects[0].object; if (intersectedObject !== currentHover && currentHover !== nodeBeingClicked) { intersectedObject = currentHover; if (intersectedObject !== currentlyQueriedNode) { intersectedObject.material.color.set(highlightColor); } infoLabel.textContent = intersectedObject.userData.label; infoDescription.textContent = intersectedObject.userData.info; infoBox.style.display = 'block'; } else if (currentHover === nodeBeingClicked) { intersectedObject = currentHover; infoLabel.textContent = intersectedObject.userData.label; infoDescription.textContent = intersectedObject.userData.info; infoBox.style.display = 'block'; } else if (intersectedObject === currentHover && currentHover !== nodeBeingClicked) { if(intersectedObject !== currentlyQueriedNode) { intersectedObject.material.color.set(highlightColor); } } } else { intersectedObject = null; infoBox.style.display = 'none'; } }

        // --- Main Animation Loop ---
        function animate() { /* ... (same) ... */ animationFrameId = requestAnimationFrame(animate); const now = Date.now(); const time = now * 0.005; controls.update(); checkIntersections(); nodes.forEach(node => { let targetScale = 1.0; let isClickEffectActive = false; if (node === nodeBeingClicked && now < clickEffectStartTime + clickEffectDuration) { const elapsed = now - clickEffectStartTime; const progress = elapsed / clickEffectDuration; node.material.color.set(clickHighlightColor); targetScale = 1.0 + Math.sin(progress * Math.PI) * 0.5; isClickEffectActive = true; } if (!isClickEffectActive) { if (node === currentlyQueriedNode) { const pulseScale = 1.0 + Math.sin(time * 2) * 0.4; targetScale = pulseScale; if (node !== intersectedObject) { node.material.color.copy(node.userData.originalColor); } else { node.material.color.set(highlightColor); } } else if (node === intersectedObject) { targetScale = 1.3; node.material.color.set(highlightColor); } else { node.material.color.copy(node.userData.originalColor); } } node.scale.set(targetScale, targetScale, targetScale); }); renderer.render(scene, camera); }

        // --- Initialize ---
        window.onload = init;

    </script>
</body>
</html>
