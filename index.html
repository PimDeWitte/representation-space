<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Representation Space Explorer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: 'Press Start 2P', cursive; color: #eee; }
        canvas { display: block; }
        #info-box, #instructions, #query-display { position: absolute; background-color: rgba(0, 0, 0, 0.7); border-radius: 8px; padding: 10px 15px; font-size: 12px; z-index: 10; }
        #info-box { top: 20px; left: 20px; border: 2px solid #0f0; color: #0f0; max-width: 300px; display: none; pointer-events: none; text-shadow: 0 0 5px #0f0; line-height: 1.6; }
        #info-box h3 { margin-top: 0; margin-bottom: 10px; font-size: 14px; text-transform: uppercase; }
        #instructions { bottom: 15px; left: 50%; transform: translateX(-50%); color: #aaa; font-size: 10px; padding: 5px 10px; text-align: center; }
        #instructions a { color: #0ff; text-decoration: none; display: block; margin-top: 5px; }
        #instructions a:hover { text-decoration: underline; }
        #query-display { top: 20px; right: 20px; border: 2px solid #0ff; color: #0ff; text-shadow: 0 0 5px #0ff; }

        /* --- Overlay Styles --- */
        #animation-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); display: none; justify-content: center; align-items: center; z-index: 100; flex-direction: column; padding: 20px; box-sizing: border-box; }
        #overlay-node-label { color: #aaa; font-size: 14px; margin-bottom: 15px; text-align: center; }
        #overlay-content { display: flex; align-items: center; justify-content: space-around; width: 80%; max-width: 800px; height: 100px; margin-bottom: 20px; position: relative; border-bottom: 1px dashed rgba(0, 255, 255, 0.3); padding-bottom: 15px; }
        .network-layer { width: 10px; height: 100%; background: linear-gradient(to bottom, rgba(0, 100, 100, 0.3), rgba(0, 200, 200, 0.6), rgba(0, 100, 100, 0.3)); border-radius: 5px; box-shadow: 0 0 8px rgba(0, 255, 255, 0.5); opacity: 0; animation: fadeInLayer 0.5s forwards; transition: box-shadow 0.15s linear, background 0.15s linear; position: relative; overflow: hidden; }
        .network-layer::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: repeating-linear-gradient( 45deg, rgba(255,255,255,0.0), rgba(255,255,255,0.0) 3px, rgba(255,255,255,0.05) 3px, rgba(255,255,255,0.05) 6px ); opacity: 0; transition: opacity 0.15s linear; }
        .network-layer:nth-child(1) { animation-delay: 0.1s; } .network-layer:nth-child(2) { animation-delay: 0.2s; } .network-layer:nth-child(3) { animation-delay: 0.3s; } .network-layer:nth-child(4) { animation-delay: 0.4s; } .network-layer:nth-child(5) { animation-delay: 0.5s; }
        .network-layer.active { box-shadow: 0 0 20px #0f0; background: linear-gradient(to bottom, rgba(0, 255, 0, 0.3), rgba(100, 255, 100, 1), rgba(0, 255, 0, 0.3)); }
        .network-layer.active::before { opacity: 0.5; }
        #signal-wave { position: absolute; left: -30px; top: 50%; height: 25px; transform: translateY(-50%); opacity: 0; transition: left 0.4s linear, opacity 0.2s linear; }
        .signal-dot-item { position: absolute; width: 6px; height: 6px; background-color: #0f0; border-radius: 50%; box-shadow: 0 0 6px #0f0; }
        #word-selection-vis { position: absolute; bottom: -10px; left: 50%; transform: translateX(-50%); width: auto; min-width: 150px; padding: 5px; background-color: rgba(0, 0, 0, 0.6); border: 1px solid #555; border-radius: 4px; text-align: center; opacity: 0; transition: opacity 0.15s ease-out; pointer-events: none; display: flex; justify-content: center; align-items: center; gap: 8px; }
        #word-selection-vis.visible { opacity: 1; }
        .prob-word { font-size: 10px; padding: 2px 4px; border-radius: 3px; }
        .prob-word.selected { color: #0f0; border: 1px solid #0f0; background-color: rgba(0, 255, 0, 0.2); font-weight: bold; }
        .prob-word.alternative { color: #777; border: 1px solid #444; background-color: rgba(80, 80, 80, 0.2); opacity: 0.7; }
        #overlay-output-container { width: 80%; max-width: 800px; min-height: 80px; text-align: left; border: 1px dashed #0ff; padding: 15px; border-radius: 5px; background-color: rgba(0, 50, 50, 0.3); margin-top: 10px; }
        #overlay-output { font-size: 16px; color: #0f0; text-shadow: 0 0 8px #0f0; line-height: 1.6; }
        #overlay-output .current-word { background-color: rgba(0, 255, 0, 0.3); padding: 0 2px; border-radius: 2px; animation: fadeHighlight 0.8s forwards; }
        #overlay-explanation { color: #888; font-size: 10px; margin-top: 20px; max-width: 600px; text-align: center; line-height: 1.5; }
        #overlay-explanation a { color: #aaa; text-decoration: underline; }
        #overlay-explanation a:hover { color: #ccc; }
        #close-overlay-btn { position: absolute; top: 20px; right: 20px; background-color: #ff0000; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-family: 'Press Start 2P', cursive; font-size: 14px; box-shadow: 0 0 10px #ff0000; transition: background-color 0.2s; }
        #close-overlay-btn:hover { background-color: #cc0000; }

        @keyframes fadeInLayer { from { opacity: 0; transform: scaleY(0.5); } to { opacity: 1; transform: scaleY(1); } }
        @keyframes nodeClickFlash { 0%, 100% { transform: scale(1.0); } 50% { transform: scale(1.5); } }
        @keyframes fadeHighlight { from { background-color: rgba(0, 255, 0, 0.3); } to { background-color: transparent; } }
    </style>
</head>
<body>
    <div id="main-visualization">
        <div id="info-box"><h3 id="info-label">...</h3><p id="info-description">...</p></div>
        <div id="instructions">
            Click & Drag: Rotate | Scroll: Zoom | Hover: Inspect | Click Concept: Animate
            <a href="https://github.com/PimDeWitte/representation-space" target="_blank" rel="noopener noreferrer">GitHub Repo</a>
        </div>
        <div id="query-display">Query: <span id="current-query">...</span></div>
        <canvas id="representation-canvas"></canvas>
    </div>

    <div id="animation-overlay">
         <div id="overlay-node-label">LLM Generation for Concept: ...</div>
         <div id="overlay-content">
            <div class="network-layer"></div> <div class="network-layer"></div> <div class="network-layer"></div> <div class="network-layer"></div> <div class="network-layer"></div>
            <div id="signal-wave"></div>
             <div id="word-selection-vis"></div>
        </div>
        <div id="overlay-output-container">
            <p id="overlay-output"></p> </div>
         <div id="overlay-explanation">
             This is a simplified view of how LLMs generate words, for a great tutorial on how this actually works, see <a href="https://www.youtube.com/watch?v=7xTGNNLPyMI&pp=ygUPa2FycGF0aHkgYW5kcmVq" target="_blank" rel="noopener noreferrer">https://www.youtube.com/watch?v=7xTGNNLPyMI&pp=ygUPa2FycGF0aHkgYW5kcmVq</a>
         </div>
        <button id="close-overlay-btn">X</button>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Configuration ---
        const nodeSize = 0.5; const highlightColor = 0x00ff00; const defaultColor = 0xffffff;
        const clickHighlightColor = 0xffffff; const queryInterval = 3000; const numNetworkLayers = 5;
        const clickEffectDuration = 500; const transitionDelay = 500; const newNodeSpread = 6;
        const numSignalDots = 5;
        const layerPassDuration = 1200; const wordSelectionDuration = 450; const wordAppendDelay = 100;
        const clusterLineColor = 0x555555;
        const clusterLineGlowColor = 0xffffff; // White glow

        // --- Helper Functions ---
        function randomPosition(baseX, baseY, baseZ, spread) { return new THREE.Vector3( baseX + (Math.random() * spread - spread / 2), baseY + (Math.random() * spread - spread / 2), baseZ + (Math.random() * spread - spread / 2) ); }
        const genericAlternatives = ["the", "a", "is"];
        // Delay helper for async/await
        const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

        // --- Node Data Generation ---
        const generatedNodes = [];
        const categories = { /* ... (same categories definition) ... */
            "Element": { labels: ["Hydrogen", "Helium", "Lithium", "Beryllium", "Boron", "Carbon", "Nitrogen", "Oxygen", "Fluorine", "Neon", "Sodium", "Magnesium", "Aluminium", "Silicon", "Phosphorus", "Sulfur", "Chlorine", "Argon", "Potassium", "Calcium"], base: [15, 15, 5] },
            "City": { labels: ["Tokyo", "Delhi", "Shanghai", "Sao Paulo", "Mumbai", "Mexico City", "Beijing", "Osaka", "Cairo", "New York", "Dhaka", "Karachi", "Buenos Aires", "Kolkata", "Istanbul", "Lagos", "Manila", "Rio de Janeiro", "Guangzhou", "Los Angeles"], base: [-15, 15, 5] },
            "Country": { labels: ["China", "India", "USA", "Indonesia", "Pakistan", "Brazil", "Nigeria", "Bangladesh", "Russia", "Mexico", "Japan", "Ethiopia", "Philippines", "Egypt", "Vietnam", "DR Congo", "Turkey", "Iran", "Germany", "Thailand"], base: [15, -15, 5] },
            "Shape": { labels: ["Circle", "Square", "Triangle", "Rectangle", "Pentagon", "Hexagon", "Octagon", "Sphere", "Cube", "Pyramid", "Cylinder", "Cone", "Torus", "Ellipse", "Rhombus", "Trapezoid", "Star", "Heart", "Cross", "Arrow"], base: [-15, -15, 5] },
            "Instrument": { labels: ["Piano", "Guitar", "Violin", "Drums", "Trumpet", "Flute", "Saxophone", "Cello", "Clarinet", "Harp", "Trombone", "Accordion", "Ukulele", "Banjo", "Mandolin", "Xylophone", "Harmonica", "Bagpipes", "Didgeridoo", "Sitar"], base: [5, 15, 15] },
            "Emotion": { labels: ["Joy", "Sadness", "Anger", "Fear", "Surprise", "Disgust", "Trust", "Anticipation", "Love", "Guilt", "Shame", "Envy", "Jealousy", "Hope", "Gratitude", "Pride", "Contempt", "Interest", "Awe", "Confusion"], base: [5, -15, 15] },
            "Science Concept": { labels: ["Gravity", "Evolution", "Relativity", "Quantum", "DNA", "Photosynthesis", "Entropy", "Thermodynamics", "Big Bang", "Black Hole", "Plate Tectonics", "Magnetism", "Electricity", "Atom", "Molecule", "Cell", "Virus", "Bacteria", "Ecosystem", "Climate"], base: [15, 5, 15] },
            "Math Concept": { labels: ["Algebra", "Calculus", "Geometry", "Trigonometry", "Statistics", "Probability", "Logic", "Set Theory", "Number Theory", "Topology", "Fractal", "Vector", "Matrix", "Integral", "Derivative", "Theorem", "Axiom", "Function", "Variable", "Constant"], base: [-15, 5, 15] },
            "Verb": { labels: ["Run", "Walk", "Think", "Create", "Analyze", "Synthesize", "Communicate", "Observe", "Learn", "Teach", "Build", "Destroy", "Explore", "Discover", "Imagine", "Calculate", "Measure", "Predict", "Test", "Validate"], base: [5, 15, -15] },
            "Adjective": { labels: ["Fast", "Slow", "Bright", "Dark", "Complex", "Simple", "Abstract", "Concrete", "Large", "Small", "Hot", "Cold", "Heavy", "Light", "Hard", "Soft", "Rough", "Smooth", "Sharp", "Dull"], base: [5, -15, -15] }
        };
        const clusterCenters = {};
        for (const categoryName in categories) { /* ... (same generation logic, includes clusterCenter) ... */
             const category = categories[categoryName]; const [bx, by, bz] = category.base; const centerPoint = new THREE.Vector3(bx, by, bz); clusterCenters[categoryName] = centerPoint;
             category.labels.forEach(label => { generatedNodes.push({ position: randomPosition(bx, by, bz, newNodeSpread), label: label, category: categoryName, clusterCenter: centerPoint, info: `...`, color: Math.random() * 0xffffff, sentence: `Concept '${label}' represents the ${categoryName.toLowerCase()} ${label}.` }); });
        }
        generatedNodes.forEach(n => { if (!n.info) n.info = `Info about ${n.label}.`; });

        // --- Original Sample Data ---
        const originalNodesData = [ /* ... (same original data with category and clusterCenter added) ... */
             { position: new THREE.Vector3(5, 0, 0), label: "Apple", category: "Fruit", clusterCenter: new THREE.Vector3(5, 0, 0), info: "...", color: 0xff0000, sentence: "The system identifies 'Apple' as a type of common fruit." }, { position: new THREE.Vector3(5.5, 0.5, 0.2), label: "Banana", category: "Fruit", clusterCenter: new THREE.Vector3(5, 0, 0), info: "...", color: 0xffff00, sentence: "Processing concept... 'Banana' is recognized as a tropical fruit." }, { position: new THREE.Vector3(4.8, -0.3, -0.5), label: "Orange", category: "Fruit", clusterCenter: new THREE.Vector3(5, 0, 0), info: "...", color: 0xffa500, sentence: "Concept activated: 'Orange', a citrus fruit high in vitamins." }, { position: new THREE.Vector3(5.2, 0.8, -0.8), label: "Grape", category: "Fruit", clusterCenter: new THREE.Vector3(5, 0, 0), info: "...", color: 0x800080, sentence: "Representation decoded: 'Grape', often found in vineyards." }, { position: new THREE.Vector3(-5, 0, 0), label: "Red", category: "Color", clusterCenter: new THREE.Vector3(-5, 0, 0), info: "...", color: 0xff0000, sentence: "Color vector 'Red' is activated in the spectrum space." }, { position: new THREE.Vector3(-5.2, 0.6, -0.3), label: "Green", category: "Color", clusterCenter: new THREE.Vector3(-5, 0, 0), info: "...", color: 0x00ff00, sentence: "Concept 'Green' represents wavelengths associated with nature." }, { position: new THREE.Vector3(-4.5, -0.5, 0.4), label: "Blue", category: "Color", clusterCenter: new THREE.Vector3(-5, 0, 0), info: "...", color: 0x0000ff, sentence: "The concept 'Blue' relates to sky and water elements." }, { position: new THREE.Vector3(-5.5, -0.2, -0.6), label: "Yellow", category: "Color", clusterCenter: new THREE.Vector3(-5, 0, 0), info: "...", color: 0xffff00, sentence: "Feature detected: 'Yellow', a bright primary color." }, { position: new THREE.Vector3(0, 0, 5), label: "Abstract", category: "Concept", clusterCenter: new THREE.Vector3(0, 0, 5), info: "...", color: 0xaaaaaa, sentence: "Conceptual input 'Abstract' signifies non-physical ideas." }, { position: new THREE.Vector3(0.5, 0.5, 5.5), label: "Concrete", category: "Concept", clusterCenter: new THREE.Vector3(0, 0, 5), info: "...", color: 0x555555, sentence: "Input 'Concrete' pertains to tangible, physical objects." }, { position: new THREE.Vector3(-0.3, -0.4, 4.8), label: "Idea", category: "Concept", clusterCenter: new THREE.Vector3(0, 0, 5), info: "...", color: 0xcccccc, sentence: "The 'Idea' input represents thoughts and suggestions." }, { position: new THREE.Vector3(0, 5, 0), label: "Dog", category: "Animal", clusterCenter: new THREE.Vector3(0, 5, 0), info: "...", color: 0x8B4513, sentence: "Animal identified: 'Dog', a common domesticated mammal." }, { position: new THREE.Vector3(0.5, 5.5, 0.3), label: "Cat", category: "Animal", clusterCenter: new THREE.Vector3(0, 5, 0), info: "...", color: 0x808080, sentence: "Recognized entity: 'Cat', a feline companion animal." }, { position: new THREE.Vector3(-0.4, 4.8, -0.2), label: "Bird", category: "Animal", clusterCenter: new THREE.Vector3(0, 5, 0), info: "...", color: 0xADD8E6, sentence: "Concept 'Bird' relates to avian vertebrates with feathers." }, { position: new THREE.Vector3(0.2, 5.2, -0.5), label: "Fish", category: "Animal", clusterCenter: new THREE.Vector3(0, 5, 0), info: "...", color: 0x00008B, sentence: "Aquatic lifeform 'Fish' identified in the biological space." }, { position: new THREE.Vector3(0, -5, 0), label: "Car", category: "Vehicle", clusterCenter: new THREE.Vector3(0, -5, 0), info: "...", color: 0x708090, sentence: "Vehicle type 'Car' represents common road transport." }, { position: new THREE.Vector3(0.6, -5.4, 0.1), label: "Bicycle", category: "Vehicle", clusterCenter: new THREE.Vector3(0, -5, 0), info: "...", color: 0xB0C4DE, sentence: "Concept 'Bicycle' signifies human-powered two-wheeled transport." }, { position: new THREE.Vector3(-0.5, -4.7, -0.3), label: "Airplane", category: "Vehicle", clusterCenter: new THREE.Vector3(0, -5, 0), info: "...", color: 0xD3D3D3, sentence: "Transport mode 'Airplane' enables powered flight." }, { position: new THREE.Vector3(0.3, -5.8, -0.6), label: "Boat", category: "Vehicle", clusterCenter: new THREE.Vector3(0, -5, 0), info: "...", color: 0x4682B4, sentence: "Watercraft 'Boat' identified for travel on water." },
        ];
        originalNodesData.forEach(n => { /* ... (same default info/sentence/center assignment) ... */
            if (!n.info) n.info = `Info about ${n.label}.`; if (!n.sentence) n.sentence = `Sentence about ${n.label}.`; if (!n.clusterCenter) { if (n.category === "Fruit") n.clusterCenter = new THREE.Vector3(5, 0, 0); else if (n.category === "Color") n.clusterCenter = new THREE.Vector3(-5, 0, 0); else if (n.category === "Concept") n.clusterCenter = new THREE.Vector3(0, 0, 5); else if (n.category === "Animal") n.clusterCenter = new THREE.Vector3(0, 5, 0); else if (n.category === "Vehicle") n.clusterCenter = new THREE.Vector3(0, -5, 0); else n.clusterCenter = new THREE.Vector3(0,0,0); } if (!clusterCenters[n.category]) { clusterCenters[n.category] = n.clusterCenter; }
         });

        const nodesData = [...originalNodesData, ...generatedNodes];
        const sampleQueries = ["Yellow Fruit", "Flying Vehicle", "Pet", "Primary Color", "Grows in Water", "Citrus", "Idea", "Engine Powered", "Element", "City", "Country", "Shape", "Instrument", "Emotion", "Science Concept", "Math Concept", "Verb", "Adjective"];
        let currentQueryIndex = 0;

        // --- Three.js Setup Variables & DOM Refs ---
        let scene, camera, renderer, controls; let raycaster, mouse; let nodes = [];
        let intersectedObject = null; let currentlyQueriedNode = null; let queryIntervalId = null;
        let animationFrameId = null; let nodeBeingClicked = null; let clickEffectStartTime = 0;
        let clusterConnectionLines = [];
        let defaultLineMaterial, glowLineMaterial; // Note: glowLineMaterial is now just the base, cloned for activation

        const infoBox = document.getElementById('info-box'); /* ... other DOM refs ... */
        const infoLabel = document.getElementById('info-label'); const infoDescription = document.getElementById('info-description');
        const canvas = document.getElementById('representation-canvas'); const currentQuerySpan = document.getElementById('current-query'); const mainVisualizationDiv = document.getElementById('main-visualization');
        const animationOverlay = document.getElementById('animation-overlay'); const overlayNodeLabel = document.getElementById('overlay-node-label'); const overlayContent = document.getElementById('overlay-content');
        const signalWaveContainer = document.getElementById('signal-wave');
        const wordSelectionVis = document.getElementById('word-selection-vis');
        const overlayOutputContainer = document.getElementById('overlay-output-container');
        const overlayOutput = document.getElementById('overlay-output');
        const closeOverlayBtn = document.getElementById('close-overlay-btn');
        const networkLayerDivs = overlayContent.querySelectorAll('.network-layer');

        // --- Initialization ---
        function init() {
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x111111); scene.fog = new THREE.Fog(0x111111, 20, 70);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.z = 25;
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(window.devicePixelRatio);
            const ambientLight = new THREE.AmbientLight(0xaaaaaa); scene.add(ambientLight); const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5); directionalLight.position.set(5, 10, 7.5); scene.add(directionalLight);
            controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.05; controls.screenSpacePanning = false; controls.minDistance = 2; controls.maxDistance = 60;
            raycaster = new THREE.Raycaster(); mouse = new THREE.Vector2();

            // Create Concept Nodes
            const geometry = new THREE.SphereGeometry(nodeSize, 16, 8);
            nodesData.forEach(data => { /* ... (same node creation, includes clusterCenter) ... */
                 const material = new THREE.MeshLambertMaterial({ color: data.color || defaultColor }); const nodeMesh = new THREE.Mesh(geometry, material); nodeMesh.position.copy(data.position);
                 nodeMesh.userData = { label: data.label, info: data.info, sentence: data.sentence, category: data.category, clusterCenter: data.clusterCenter, originalColor: new THREE.Color(data.color || defaultColor), isNode: true };
                 scene.add(nodeMesh); nodes.push(nodeMesh);
             });

             // Create Cluster Connection Lines Materials
             defaultLineMaterial = new THREE.LineBasicMaterial({ color: clusterLineColor, transparent: true, opacity: 0.3 });
             glowLineMaterial = new THREE.LineBasicMaterial({ color: clusterLineGlowColor, transparent: true, opacity: 1.0 }); // Base glow material, opacity set on clone

             // Create Individual Cluster Connection Lines
             const centerPoints = Object.values(clusterCenters);
             for (let i = 0; i < centerPoints.length; i++) {
                 for (let j = i + 1; j < centerPoints.length; j++) {
                     const points = [centerPoints[i], centerPoints[j]];
                     const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                     const line = new THREE.Line(lineGeometry, defaultLineMaterial);
                     scene.add(line);
                     clusterConnectionLines.push({ line: line, centerA: centerPoints[i], centerB: centerPoints[j] });
                 }
             }

            // Create signal dot elements
            signalWaveContainer.innerHTML = '';
            for (let i = 0; i < numSignalDots; i++) { /* ... (same dot creation) ... */
                const dot = document.createElement('div'); dot.classList.add('signal-dot-item');
                dot.style.top = `${(i / (numSignalDots - 1)) * 100 - 50}%`; dot.style.transform = `translateY(-50%)`;
                signalWaveContainer.appendChild(dot);
            }

            window.addEventListener('resize', onWindowResize, false); window.addEventListener('mousemove', onMouseMove, false);
            canvas.addEventListener('click', onCanvasClick, false); closeOverlayBtn.addEventListener('click', hideAnimationOverlay, false);
            startQueryCycle(); startAnimationLoop();
         }

        // --- Animation Loop Control ---
        function startAnimationLoop() { if (!animationFrameId) { animate(); } }
        function stopAnimationLoop() { if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } }

        // --- Event Handlers ---
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        function onMouseMove(event) { mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1; }
        function onCanvasClick(event) { /* ... (same click logic) ... */
            if (animationOverlay.style.display === 'flex' || nodeBeingClicked) return;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera); const intersects = raycaster.intersectObjects(nodes);
            if (intersects.length > 0 && intersects[0].object.userData.isNode) {
                const clickedNode = intersects[0].object;
                if (clickedNode.userData.sentence) {
                    nodeBeingClicked = clickedNode; clickEffectStartTime = Date.now();
                    setTimeout(() => { if (nodeBeingClicked === clickedNode) { showAnimationOverlay(clickedNode.userData.label, clickedNode.userData.sentence); nodeBeingClicked = null; } }, transitionDelay);
                }
            }
        }

        // --- Overlay Animation Logic ---
        let animationControl = { timeoutId: null, wordIndex: 0, words: [], isCancelled: false }; // Added cancel flag

        function showAnimationOverlay(label, sentence) {
            stopAnimationLoop(); mainVisualizationDiv.style.display = 'none';
            overlayNodeLabel.textContent = `LLM Generation for Concept: ${label}`;
            animationOverlay.style.display = 'flex';

            // Reset state
            clearTimeout(animationControl.timeoutId); // Clear any pending timeouts
            animationControl.isCancelled = false; // Reset cancel flag
            signalWaveContainer.style.transition = 'none'; signalWaveContainer.style.opacity = '0'; signalWaveContainer.style.left = '-30px';
            overlayOutput.innerHTML = '';
            wordSelectionVis.innerHTML = ''; wordSelectionVis.classList.remove('visible');
            networkLayerDivs.forEach(layer => layer.classList.remove('active'));
            void signalWaveContainer.offsetWidth;

            animationControl.words = sentence.split(' ');
            animationControl.wordIndex = 0;
            animateLLMStep(); // Start the animation
        }

        function hideAnimationOverlay() {
             animationControl.isCancelled = true; // Set flag to stop ongoing animation loops
             clearTimeout(animationControl.timeoutId); // Clear any pending timeouts
             animationOverlay.style.display = 'none'; mainVisualizationDiv.style.display = 'block';
             nodeBeingClicked = null; startAnimationLoop();
        }

        // Refactored using async/await and cancel flag
        async function animateLLMStep() {
            if (animationControl.isCancelled) return; // Stop if cancelled

            if (animationControl.wordIndex >= animationControl.words.length) {
                wordSelectionVis.innerHTML = `<span class="prob-word selected">Complete!</span>`;
                wordSelectionVis.classList.add('visible');
                animationControl.timeoutId = setTimeout(() => { if (!animationControl.isCancelled) wordSelectionVis.classList.remove('visible'); }, 1500);
                return;
            }

            const currentWord = animationControl.words[animationControl.wordIndex];
            const stepDuration = layerPassDuration / (numNetworkLayers + 1);

            // --- Pass through layers ---
            signalWaveContainer.style.transition = 'none'; // Reset for positioning
            signalWaveContainer.style.left = '-30px';
            void signalWaveContainer.offsetWidth;
            signalWaveContainer.style.opacity = '1';
            signalWaveContainer.style.transition = `left ${stepDuration}ms linear, opacity 0.2s linear`; // Apply transition for movement

            for (let currentLayer = 1; currentLayer <= numNetworkLayers + 1; currentLayer++) {
                if (animationControl.isCancelled) return; // Check cancellation during loop

                // Calculate target position
                const targetX = ( (currentLayer -1) * (overlayContent.offsetWidth / numNetworkLayers)) ; // Move towards start of next segment
                signalWaveContainer.style.left = `${targetX}px`;

                // Highlight current layer, unhighlight previous
                if (currentLayer > 1 && currentLayer <= numNetworkLayers + 1) {
                    networkLayerDivs[currentLayer - 2].classList.remove('active');
                }
                 if (currentLayer > 0 && currentLayer <= numNetworkLayers) {
                    networkLayerDivs[currentLayer - 1].classList.add('active');
                 }

                await delay(stepDuration); // Wait for movement/highlight
            }
             if (!animationControl.isCancelled && numNetworkLayers > 0) { // Unhighlight last layer
                 networkLayerDivs[numNetworkLayers - 1].classList.remove('active');
             }
             signalWaveContainer.style.opacity = '0'; // Hide wave after pass

            // --- Word Selection Visualization ---
            if (animationControl.isCancelled) return;
            wordSelectionVis.innerHTML = ''; // Clear previous
            genericAlternatives.forEach(altWord => { if (altWord !== currentWord) { const altSpan = document.createElement('span'); altSpan.textContent = altWord; altSpan.classList.add('prob-word', 'alternative'); wordSelectionVis.appendChild(altSpan); } });
            const selectedSpan = document.createElement('span'); selectedSpan.textContent = currentWord; selectedSpan.classList.add('prob-word', 'selected'); const insertIndex = Math.floor(Math.random() * (wordSelectionVis.children.length + 1)); wordSelectionVis.insertBefore(selectedSpan, wordSelectionVis.children[insertIndex]);
            wordSelectionVis.classList.add('visible');

            await delay(wordSelectionDuration); // Wait for user to see selection

            // --- Append Word ---
            if (animationControl.isCancelled) return;
            wordSelectionVis.classList.remove('visible');
            const span = document.createElement('span'); span.textContent = currentWord + ' '; span.classList.add('current-word');
            overlayOutput.appendChild(span);
            animationControl.wordIndex++;

            // --- Schedule Next Step ---
            if (!animationControl.isCancelled) {
                 animationControl.timeoutId = setTimeout(animateLLMStep, wordAppendDelay);
            }
        }


        // --- Core Logic (Query Cycle, Intersection Checks) ---
        function startQueryCycle() { /* ... (same) ... */ if (queryIntervalId) clearInterval(queryIntervalId); const runQuery = () => { const query = sampleQueries[currentQueryIndex]; currentQuerySpan.textContent = query; processQuery(query); currentQueryIndex = (currentQueryIndex + 1) % sampleQueries.length; }; runQuery(); queryIntervalId = setInterval(runQuery, queryInterval); }

        // Updated processQuery for random line glow opacity (reduced range)
        function processQuery(query) {
            currentlyQueriedNode = null;
            // Reset all lines to default material FIRST
            clusterConnectionLines.forEach(lineData => {
                if (lineData.line.material !== defaultLineMaterial) {
                     lineData.line.material = defaultLineMaterial;
                }
            });

            const queryLower = query.toLowerCase(); const queryWords = queryLower.split(' '); let bestMatch = null;
            for (const node of nodes) { /* ... (find bestMatch same as before) ... */
                const labelLower = node.userData.label.toLowerCase(); const infoLower = node.userData.info.toLowerCase(); let matchScore = 0; for(const word of queryWords) { if (labelLower.includes(word) || infoLower.includes(word) || (node.userData.category && node.userData.category.toLowerCase().includes(word))) { matchScore++; } } if (matchScore > 0) { if (!bestMatch) { bestMatch = node; } }
            }
            currentlyQueriedNode = bestMatch;

            if (currentlyQueriedNode && currentlyQueriedNode.userData.clusterCenter) {
                const targetCenter = currentlyQueriedNode.userData.clusterCenter;
                clusterConnectionLines.forEach(lineData => {
                    if (lineData.centerA.equals(targetCenter) || lineData.centerB.equals(targetCenter)) {
                        lineData.line.material = glowLineMaterial.clone();
                        // Set random opacity simulating weight (Reduced Range: 0.25 to 0.5)
                        lineData.line.material.opacity = (Math.random() * 0.5 + 0.5) * 0.5;
                    }
                });
            }
         }

        function checkIntersections() { /* ... (same) ... */ raycaster.setFromCamera(mouse, camera); const intersects = raycaster.intersectObjects(nodes); if (intersectedObject && intersectedObject !== currentlyQueriedNode && intersectedObject !== nodeBeingClicked) { intersectedObject.material.color.copy(intersectedObject.userData.originalColor); } if (intersects.length > 0 && intersects[0].object.userData.isNode) { const currentHover = intersects[0].object; if (intersectedObject !== currentHover && currentHover !== nodeBeingClicked) { intersectedObject = currentHover; if (intersectedObject !== currentlyQueriedNode) { intersectedObject.material.color.set(highlightColor); } infoLabel.textContent = intersectedObject.userData.label; infoDescription.textContent = intersectedObject.userData.info; infoBox.style.display = 'block'; } else if (currentHover === nodeBeingClicked) { intersectedObject = currentHover; infoLabel.textContent = intersectedObject.userData.label; infoDescription.textContent = intersectedObject.userData.info; infoBox.style.display = 'block'; } else if (intersectedObject === currentHover && currentHover !== nodeBeingClicked) { if(intersectedObject !== currentlyQueriedNode) { intersectedObject.material.color.set(highlightColor); } } } else { intersectedObject = null; infoBox.style.display = 'none'; } }

        // --- Main Animation Loop ---
        function animate() { /* ... (same) ... */ animationFrameId = requestAnimationFrame(animate); const now = Date.now(); const time = now * 0.005; controls.update(); checkIntersections(); nodes.forEach(node => { let targetScale = 1.0; let isClickEffectActive = false; if (node === nodeBeingClicked && now < clickEffectStartTime + clickEffectDuration) { const elapsed = now - clickEffectStartTime; const progress = elapsed / clickEffectDuration; node.material.color.set(clickHighlightColor); targetScale = 1.0 + Math.sin(progress * Math.PI) * 0.5; isClickEffectActive = true; } if (!isClickEffectActive) { if (node === currentlyQueriedNode) { const pulseScale = 1.0 + Math.sin(time * 2) * 0.4; targetScale = pulseScale; if (node !== intersectedObject) { node.material.color.copy(node.userData.originalColor); } else { node.material.color.set(highlightColor); } } else if (node === intersectedObject) { targetScale = 1.3; node.material.color.set(highlightColor); } else { node.material.color.copy(node.userData.originalColor); } } node.scale.set(targetScale, targetScale, targetScale); }); renderer.render(scene, camera); }

        // --- Initialize ---
        window.onload = init;

    </script>
</body>
</html>
